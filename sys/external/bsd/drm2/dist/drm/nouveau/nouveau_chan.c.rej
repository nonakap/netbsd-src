--- nouveau/nouveau_chan.c	2016-07-22 15:48:08.000000000 +0900
+++ nouveau/nouveau_chan.c	2016-07-12 01:31:24.000000000 +0900
@@ -86,18 +86,13 @@ nouveau_channel_del(struct nouveau_chann
 }
 
 static int
-nouveau_channel_prep(struct nouveau_drm *drm, struct nouveau_cli *cli,
-		     u32 parent, u32 handle, u32 size,
-		     struct nouveau_channel **pchan)
+nouveau_channel_prep(struct nouveau_drm *drm, struct nvif_device *device,
+		     u32 size, struct nouveau_channel **pchan)
 {
-	struct nouveau_device *device = nv_device(drm->device);
-	struct nouveau_instmem *imem = nouveau_instmem(device);
-	struct nouveau_vmmgr *vmm = nouveau_vmmgr(device);
-	struct nouveau_fb *pfb = nouveau_fb(device);
-	struct nouveau_client *client = &cli->base;
-	struct nv_dma_class args = {};
+	struct nouveau_cli *cli = (void *)device->object.client;
+	struct nvkm_mmu *mmu = nvxx_mmu(device);
+	struct nv_dma_v0 args = {};
 	struct nouveau_channel *chan;
-	struct nouveau_object *push;
 	u32 target;
 	int ret;
 
@@ -297,60 +326,60 @@ nouveau_channel_dma(struct nouveau_drm *
 static int
 nouveau_channel_init(struct nouveau_channel *chan, u32 vram, u32 gart)
 {
-	struct nouveau_client *client = nv_client(chan->cli);
-	struct nouveau_device *device = nv_device(chan->drm->device);
-	struct nouveau_instmem *imem = nouveau_instmem(device);
-	struct nouveau_vmmgr *vmm = nouveau_vmmgr(device);
-	struct nouveau_fb *pfb = nouveau_fb(device);
-	struct nouveau_software_chan *swch;
-	struct nouveau_object *object;
-	struct nv_dma_class args = {};
+	struct nvif_device *device = chan->device;
+	struct nouveau_cli *cli = (void *)chan->user.client;
+	struct nvkm_mmu *mmu = nvxx_mmu(device);
+	struct nv_dma_v0 args = {};
 	int ret, i;
 
+	nvif_object_map(&chan->user);
+
 	/* allocate dma objects to cover all allowed vram, and gart */
-	if (device->card_type < NV_C0) {
-		if (device->card_type >= NV_50) {
-			args.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_VM;
+	if (device->info.family < NV_DEVICE_INFO_V0_FERMI) {
+		if (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {
+			args.target = NV_DMA_V0_TARGET_VM;
+			args.access = NV_DMA_V0_ACCESS_VM;
 			args.start = 0;
-			args.limit = client->vm->vmm->limit - 1;
+			args.limit = cli->vm->mmu->limit - 1;
 		} else {
-			args.flags = NV_DMA_TARGET_VRAM | NV_DMA_ACCESS_RDWR;
+			args.target = NV_DMA_V0_TARGET_VRAM;
+			args.access = NV_DMA_V0_ACCESS_RDWR;
 			args.start = 0;
-			args.limit = pfb->ram->size - imem->reserved - 1;
+			args.limit = device->info.ram_user - 1;
 		}
 
-		ret = nouveau_object_new(nv_object(client), chan->handle, vram,
-					 0x003d, &args, sizeof(args), &object);
+		ret = nvif_object_init(&chan->user, vram, NV_DMA_IN_MEMORY,
+				       &args, sizeof(args), &chan->vram);
 		if (ret)
 			return ret;
 
-		if (device->card_type >= NV_50) {
-			args.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_VM;
+		if (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {
+			args.target = NV_DMA_V0_TARGET_VM;
+			args.access = NV_DMA_V0_ACCESS_VM;
 			args.start = 0;
-			args.limit = client->vm->vmm->limit - 1;
+			args.limit = cli->vm->mmu->limit - 1;
 		} else
-		if (chan->drm->agp.stat == ENABLED) {
-			args.flags = NV_DMA_TARGET_AGP | NV_DMA_ACCESS_RDWR;
+		if (chan->drm->agp.bridge) {
+			args.target = NV_DMA_V0_TARGET_AGP;
+			args.access = NV_DMA_V0_ACCESS_RDWR;
 			args.start = chan->drm->agp.base;
 			args.limit = chan->drm->agp.base +
 				     chan->drm->agp.size - 1;
 		} else {
-			args.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_RDWR;
+			args.target = NV_DMA_V0_TARGET_VM;
+			args.access = NV_DMA_V0_ACCESS_RDWR;
 			args.start = 0;
-			args.limit = vmm->limit - 1;
+			args.limit = mmu->limit - 1;
 		}
 
-		ret = nouveau_object_new(nv_object(client), chan->handle, gart,
-					 0x003d, &args, sizeof(args), &object);
+		ret = nvif_object_init(&chan->user, gart, NV_DMA_IN_MEMORY,
+				       &args, sizeof(args), &chan->gart);
 		if (ret)
 			return ret;
-
-		chan->vram = vram;
-		chan->gart = gart;
 	}
 
 	/* initialise dma tracking parameters */
-	switch (nv_hclass(chan->object) & 0x00ff) {
+	switch (chan->user.oclass & 0x00ff) {
 	case 0x006b:
 	case 0x006e:
 		chan->user_put = 0x40;
